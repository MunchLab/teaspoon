Code for using \href{https://github.com/Ripser/ripser}{\tt Ripser}, \href{http://people.maths.ox.ac.uk/nanda/perseus/index.html}{\tt Perseus}, and \href{https://bitbucket.org/grey_narn/hera}{\tt Hera} in python.

\subsection*{General notes on format}

All diagrams are stored as an Lx2 numpy matrix. Code for computing persistence returns a dictionary with multiple dimensions of persistence where keys are the dimensions. 
\begin{DoxyCode}
1 Dgms = \{
2     0: DgmDimension0,
3     1: DgmDimension1,
4     2: DgmDimension2
5 \}
\end{DoxyCode}
 Infinite classes are given an entry of np.\+inf. {\itshape T\+O\+DO\+: Check that this is true.}

In the process of computation, data files are saved in a hidden folder .teaspoon\+Data This folder is created if it doesn\textquotesingle{}t already exist. Files are repeatedly emptied out of it, so do not save anything in it that you might want later! 



\subsection*{Persistence for Point Clouds}

\subsubsection*{Using Ripser}

To date, this is the fastest code for doing point cloud persistence. Computes persistence of a point cloud using \href{https://github.com/Ripser/ripser}{\tt Ripser}.


\begin{DoxyCode}
1 VR\_Ripser(P, maxDim = 1)
\end{DoxyCode}


Note\+: This code actually just computes the pairwise distance matrix and passes it to dist\+Mat\+\_\+\+Ripser

\paragraph*{Parameters}


\begin{DoxyItemize}
\item P = A point cloud as an NxD numpy array. N is the number of points, D is the dimension of Euclidean space.
\item max\+Dim = An integer representing the maximum dimension for computing persistent homology.
\end{DoxyItemize}

\paragraph*{Returns}


\begin{DoxyItemize}
\item Dgms = A dictionary where Dgms\mbox{[}k\mbox{]} is an Lx2 matrix, where L is the number of points in the persistence diagram. Infinite classes are given with an np.\+inf entry.
\end{DoxyItemize}

\subsubsection*{Using Perseus}


\begin{DoxyCode}
1 VR\_Perseus(P,dim = 1, 
2             maxRadius = 3, numSteps = 100, stepSize = None,
3             suppressOutput = True)
\end{DoxyCode}


Does brips version of perseus. Computes VR persitsence on points in Euclidean space.

\paragraph*{Warnings\+:}


\begin{DoxyEnumerate}
\item Requires choice of max\+Radius, num\+Steps, and/or step\+Size. Bad choices will give junk results. So, you\textquotesingle{}ll need at least a little knowledge of your data a priori.
\item T\+O\+DO\+: Perseus appears to spit out radius rather than diameter persistence computations. Need to figure this out and make the choice uniform across outputs.
\end{DoxyEnumerate}

\paragraph*{Parameters}


\begin{DoxyItemize}
\item P
\begin{DoxyItemize}
\item An NxD array. Represents N points in R$^\wedge$D.
\end{DoxyItemize}
\item max\+Radius, step\+Size, num\+Steps
\begin{DoxyItemize}
\item Only 2 of the three entries should be passed.
\item Perseus requires that you decide how many steps, and how wide they are, rather than computing all possible topological changes. So, persistence will be calculated from parameter 0 until max\+Radius = step\+Size$\ast$num\+Steps.
\item If num\+Steps and step\+Size are passed (regardless of whether max\+Radius is passed), they will be used for the computation. Otherwise, the two non-\/none valued entries will be used to calculate the third. {\itshape T\+O\+DO\+: Check that this is actually the behavior!}
\end{DoxyItemize}
\item suppress\+Output
\begin{DoxyItemize}
\item If true, gets rid of printed output from perseus.
\end{DoxyItemize}
\end{DoxyItemize}

\paragraph*{Outputs}


\begin{DoxyItemize}
\item Dgms
\begin{DoxyItemize}
\item A dictionary with integer keys 0,1,...,N The key gives the dimension of the persistence diagram.
\end{DoxyItemize}
\end{DoxyItemize}





\subsection*{Persistence for Distance Matrices}

Computes persistence of data given as a pairwise distance matrix using \href{https://github.com/Ripser/ripser}{\tt Ripser}.


\begin{DoxyCode}
1 distMat\_Ripser(distMat, maxDim = 1)
\end{DoxyCode}


\paragraph*{Parameters}


\begin{DoxyItemize}
\item dist\+Mat
\begin{DoxyItemize}
\item A pairwise distance matrix (note\+: symmetric!) given as an NxN numpy array.
\end{DoxyItemize}
\item max\+Dim
\begin{DoxyItemize}
\item An integer representing the maximum dimension for computing persistent homology.
\end{DoxyItemize}
\end{DoxyItemize}

\paragraph*{Returns}


\begin{DoxyItemize}
\item Dgms = A dictionary where Dgms\mbox{[}k\mbox{]} is an Lx2 matrix, where L is the number of points in the persistence diagram. Infinite classes are given with an np.\+inf entry.
\end{DoxyItemize}





\subsection*{Persistence for Cubical Complexes (Images)}

Computes persistence for a matrix of function values. Uses Vidit Nanda\textquotesingle{}s perseus.


\begin{DoxyCode}
1 Cubical\_Perseus(M, numDigits = 2, suppressOutput = True):
\end{DoxyCode}


{\bfseries Warnings\+:}


\begin{DoxyEnumerate}
\item Perseus must be in the bash path
\item Matrix must be 2-\/dimensional. {\itshape T\+O\+DO\+: Update this to accept higher dimensional cubical complexes.}
\end{DoxyEnumerate}

\paragraph*{Parameters\+:}


\begin{DoxyItemize}
\item M
\begin{DoxyItemize}
\item A 2D numpy array representing the image.
\end{DoxyItemize}
\item num\+Digits
\begin{DoxyItemize}
\item Perseus only accepts positive integer valued matrices. To compensate, we apply the transformation {\ttfamily x -\/$>$ x$\ast$ (10$\ast$$\ast$num\+Digits) + M.\+min()} then calculate persistence on the resulting matrix. The persistence diagram birth/death times are then converted back via the inverse transform.
\end{DoxyItemize}
\item suppress\+Output
\begin{DoxyItemize}
\item If true, gets rid of printed output from perseus.
\end{DoxyItemize}
\end{DoxyItemize}

\paragraph*{Outputs}


\begin{DoxyItemize}
\item Dgms
\begin{DoxyItemize}
\item A dictionary with integer keys 0,1,...,N. The key gives the dimension of the persistence diagram. 

 
\end{DoxyItemize}
\end{DoxyItemize}